{"name":"Stabilize Token","permission":{"default":0,"PN55ItGPHjs7sY8L":3},"type":"script","flags":{"core":{"sourceId":"Macro.d699WQo7DT5zrIK7"}},"scope":"global","command":"(async ()=>{\n    \n    if (canvas.tokens.controlled.length !== 1) {\n        ui.notifications.error(\"Select one and only one token\");\n        return;\n    }\n\n    game.lancer.stabilizeMacro(canvas.tokens.controlled[0].actor.id);\n\n})();","author":"PN55ItGPHjs7sY8L","img":"systems/lancer/assets/icons/macro-icons/marker.svg","actorIds":[],"_id":"JJibZu1uKQAGTdp2"}
{"_id":"Q07qegz0pYbqIk61","name":"Structure Token","type":"script","author":"eC9B4k0LaO1597E7","img":"systems/lancer/assets/icons/macro-icons/condition_shredded.svg","scope":"global","command":"if (canvas.tokens.controlled.length !== 1) {\n    ui.notifications.error(\"Select one and only one token\");\n    return;\n}\ngame.lancer.prepareStructureMacro(token.actor);","folder":null,"sort":0,"permission":{"default":0,"eC9B4k0LaO1597E7":3},"flags":{"core":{"sourceId":"Macro.QwWNUKDeT8QcV1Hs"}}}
{"name":"Full Repair","permission":{"default":0,"PN55ItGPHjs7sY8L":3},"type":"script","flags":{"core":{"sourceId":"Macro.SaR8ruxHJ8xpF1Wj"}},"scope":"global","command":"(async ()=>{\n    \n    if (canvas.tokens.controlled.length !== 1) {\n        ui.notifications.error(\"Select one and only one token\");\n        return;\n    }\n\n    game.lancer.fullRepairMacro(canvas.tokens.controlled[0].actor.id);\n\n})();","author":"PN55ItGPHjs7sY8L","img":"systems/lancer/assets/icons/macro-icons/repair.svg","actorIds":[],"_id":"RUi3krm3oDSFiIvh"}
{"_id":"kk1B4eEs5kxMhcMy","name":"Overheat Token","type":"script","author":"eC9B4k0LaO1597E7","img":"systems/lancer/assets/icons/macro-icons/damage_heat.svg","scope":"global","command":"if (canvas.tokens.controlled.length !== 1) {\n  ui.notifications.error(\"Select one and only one token\");\n  return;\n}\ngame.lancer.prepareOverheatMacro(token.actor);","folder":null,"sort":0,"permission":{"default":0,"eC9B4k0LaO1597E7":3},"flags":{"core":{"sourceId":"Macro.bzlNd5XL876ZeG16"}}}
{"_id":"3KPsYon0LoANWX54","name":"Scan","type":"script","author":"2a2IgZ2kiAqXSGqu","img":"systems/lancer/assets/icons/macro-icons/tech_quick.svg","scope":"global","command":"let targets = Array.from(game.user.targets);\n\nfunction sort_features(a, b) {\n    return b.Origin.base-a.Origin.base\n}\n\nfunction construct_features(sc_dir, o) {\n    let sc_list = ``;\n    sc_list += `<p>${o}</p>`\n    let sc_features = sc_dir._features.filter(f => f.Origin.name == o).sort(sort_features)\n    sc_features.forEach(i => {\n        let sc_name = ``;\n        let sc_desc = ``;\n        if (i.Origin.name == \"EXOTIC\" && !i.Origin.base) {\n            sc_name = \"<code class=\\\"horus--subtle\\\">UNKNOWN EXOTIC SYSTEM</code>\";\n            sc_desc = \"???\";\n        }\n        else {\n            sc_name = i.Name;\n            if (i.Effect) {\n                sc_desc = i.Effect;\n            } else {\n                sc_desc = \"No description given.\";\n            }\n            if (i.Trigger) {\n                sc_desc = `Trigger:${i.Trigger}<br>${sc_desc}`;\n            }\n        }\n        let sc_entry = `<details><summary>${sc_name}</summary><p>${sc_desc}</p></details>`;\n        sc_list += sc_entry;\n    });\n    return sc_list\n}\n\nfunction construct_templates(sc_dir) {\n    let sc_templates = ``;\n    let sc_temp = sc_dir._templates;\n    if (!sc_temp || sc_temp.length == 0) {\n        sc_templates += \"<p>NONE</p>\";\n    } else {\n        sc_temp.forEach(i => {\n            let sc_entry = `<p>${i.Name}</p>`;\n            sc_templates += sc_entry;\n        });\n    }\n\n    sc_templates += \"<br>\";\n    return sc_templates\n}\n\ntargets.forEach(target => {\n    let sc_dir = target.document.actor._prev_derived.mm\n    let hase_table_html = `\n    <table>\n        <tr>\n            <th>HULL</th><th>AGI</th><th>SYS</th><th>ENG</th>\n        </tr>\n        <tr>\n            <td>${sc_dir.Hull || 0}</td><td>${sc_dir.Agi || 0}</td><td>${sc_dir.Sys || 0}</td><td>${sc_dir.Eng || 0}</td>\n        </tr>\n    </table>\n    `\n    let stat_table_html = `\n    <table>\n        <tr>\n            <th>Armor</th><th>HP</th><th>Heat</th><th>Speed</th>\n        </tr>\n        <tr>\n            <td>${sc_dir.Armor}</td><td>${sc_dir.CurrentHP}/${sc_dir.MaxHP}</td><td>${sc_dir.CurrentHeat || 0}/${sc_dir.HeatCapacity || 0}</td><td>${sc_dir.Speed}</td>\n        </tr>\n        <tr>\n            <th>Evasion</th><th>E-Def</th><th>Save</th><th>Sensors</th>\n        </tr>\n        <tr>\n            <td>${sc_dir.Evasion}</td><td>${sc_dir.EDefense}</td><td>${sc_dir.SaveTarget}</td><td>${sc_dir.SensorRange}</td>\n        </tr>\n        <tr>\n            <th>Size</th><th>Activ</th><th>Struct</th><th>Stress</th>\n        </tr>\n        <tr>\n            <td>${sc_dir.Size}</td><td>${sc_dir.Activations || 1}</td><td>${sc_dir.CurrentStructure || 0}/${sc_dir.MaxStructure || 0}</td><td>${sc_dir.CurrentStress || 0}/${sc_dir.MaxStress || 0}</td>\n        </tr>\n    </table>\n    `\n    console.log(sc_dir)\n    let sc_class = (!sc_dir._classes || sc_dir._classes.length == 0) ? \"NONE\" : sc_dir._classes[0].Name\n    let sc_tier = sc_dir.Tier ? sc_dir.Tier : 0\n    let sc_templates = construct_templates(sc_dir)\n    let sc_list = ``\n    if (!sc_dir._features || sc_dir._features.length == 0) {\n        sc_list += \"<p>NONE</p>\";\n    } else {\n        let sc_origins = new Array\n        sc_dir._features.forEach(f => {\n            let origin = f.Origin.name\n            if (!sc_origins.includes(origin)) {\n                sc_origins.push(origin)\n            }\n        })\n        sc_origins.forEach(o => {\n            sc_list += construct_features(sc_dir, o)\n        })\n    }\n\n    ChatMessage.create({\n        user: game.user._id,\n        content: `<h2>Scan results: ${sc_dir.Name}</h2>` + `<h3>Class: ${sc_class}, Tier ${sc_tier}</h3>`  + hase_table_html + stat_table_html + `<h3>Templates:</h3>` + sc_templates + `<h3>Systems:</h3>` + sc_list\n    });\n})","folder":null,"sort":0,"permission":{"default":0,"2a2IgZ2kiAqXSGqu":3},"flags":{}}
{"name":"Scan (Journal)","type":"script","author":"2a2IgZ2kiAqXSGqu","img":"systems/lancer/assets/icons/macro-icons/tech_quick.svg","scope":"global","command":"\/\/Sanity Check - Can this user even create folders and journal entries? Does the folder journal folder exist?\nif (JournalEntry.canUserCreate(game.user) === false) {\n    ui.notifications.error(`${game.user.name} attempted to run SCAN to Journal but lacks proper permissions. Please correct and try again.`);\n    return;\n}\n\n\/\/Variables - Change these to control the macro\n\n\/\/journalFolderName - The name, as displayed in foundry, of the folder you want the journal entries to save to. Remember to enclose in quotes: \'example\'\nvar journalFolderName = \'SCAN Database\';\n\n\/\/nameTemplate - The text before the scan number and target name. Remember to enclose in quotes: \'example\'\nvar nameTemplate = \'SCAN: \';\n\n\/\/numberLength - The total length of the scan number, extra spaces are filled with 0s. Setting this to 3, for example would produce scan number 001 on your first scan. Integers only and no quotes.\nvar numberLength = 3;\n\n\/\/startingNumber - If you want the scan number to start at something other than 1 then change this. Integers only and no quotes.\nvar startingNumber = 1;\n\n\/\/permissionLevel - This sets the default permission level of the scan entry. This must be an integer between 0 and 3 where 0 is \"None\", 1 is \"Limited\", 2 is \"Observer\", and 3 is \"Owner\"\nvar permissionLevel = 3;\n\n\/\/updateExisting - This macro will check if a scan journal entry exists and update it, set this to false if you want it to create a new scan journal entry.\nvar updateExisting = true;\n\n\/\/ noiseSymbols - Set this to the set of characters or short strings you want to use for malfunctioning scans with Abominable Horror targets.\n\/\/ The default set comes from the OEM-US character set, codepage 437.\nconst glitchSymbols = [\n    \'¿\', \'⌐\', \'¬\', \'¡\', \'«\', \'»\', \'░\', \'▒\', \'▓\',\n    \'│\', \'┤\', \'╡\', \'╢\', \'╖\', \'╕\', \'╣\', \'║\', \'╗\',\n    \'╝\', \'╜\', \'╛\', \'┐\', \'└\', \'┴\', \'┬\', \'├\', \'─\',\n    \'┼\', \'╞\', \'╟\', \'╚\', \'╔\', \'╩\', \'╦\', \'╠\', \'═\',\n    \'╬\', \'╧\', \'╨\', \'╤\', \'╥\', \'╙\', \'╘\', \'╒\', \'╓\',\n    \'╫\', \'╪\', \'┘\', \'┌\', \'█\', \'▄\', \'▌\', \'▐\', \'▀\',\n    \'α\', \'ß\', \'Γ\', \'π\', \'Σ\', \'σ\', \'µ\', \'τ\', \'Φ\',\n    \'Θ\', \'Ω\', \'δ\', \'∞\', \'φ\', \'ε\', \'∩\', \'≡\', \'±\',\n    \'≥\', \'≤\', \'⌠\', \'⌡\', \'÷\', \'≈\', \'°\', \'∙\', \'·\',\n    \'√\', \'ⁿ\', \'²\', \'■\', \'☺\', \'☻\', \'♥\', \'♦\', \'♣\',\n    \'♠\', \'•\', \'◘\', \'○\', \'◙\', \'♂\', \'♀\', \'♪\', \'♫\',\n    \'☼\', \'►\', \'◄\', \'↕\', \'‼\', \'¶\', \'§\', \'▬\', \'↨\',\n    \'↑\', \'↓\', \'→\', \'←\', \'∟\', \'↔\', \'▲\', \'▼\', \'#\',\n    \'$\', \'&\', \'*\', \'½\', \'¼\', \'æ\', \'Æ\', \'!\', \'₧\',\n    \'¥\', \'£\', \'ƒ\', \'¢\', \'?\', \'0\', \'x\', \'X\', \' \']\n\n\/\/ glitchNumberLength - Set this to the length of a string of glitchSymbols to add in place of numbers that scan would normally reveal.\nconst glitchNumberLength = {\n    min: 2,\n    max: 4,\n}\n\n\/\/ errorText - Set this to the set of short texts to sprinkle into longer error texts, such as in headers and system names, for scans with Abominable Horror targets.\nconst errorText = [\n    \'ERR\', \'ERROR\', \'MALFUNCTION\', \'STATUS\',\n    \'SCAN\', \'SCANNING\', \'SCANNED\', \'CORRUPT\',\n    \'CORRUPTED\', \'CORRUPTION\', \'FAIL\', \'FAILURE\',\n    \'SYSTEM\', \'WARN\', \'WARNING\', \'DATA\', \'HORROR\',\n    \'ABOMINABLE\', \'DETECT\', \'DETECTED\', \'DETECTION\',\n    \'ABORT\', \'ABORTED\', \'UNEXPECTED\', \'UNKNOWN\',\n    \'UNFORESEEN\',  \'INVALID\', \'BAD\', \'MEMORY\',\n    \'ACCESS\', \'PROTOCOL\', \'GLITCH\', \'BUFFER\',\n    \'OVERFLOW\', \'UNDERRUN\', \'ACCESS\', \'DENY\',\n    \'DENIED\', \'FATAL\', \'STACK\', \'PARSE\',\n    \'WEAPON\', \'SYSTEM\', \'MECH\', \'DANGER\',\n    \'NOMINAL\', \'OK\', \'SUCCESS\', \'UNDEFINED\'\n]\n\n\/\/ errorTextPadding: The minimum and maximum (inclusive) number of glitchSymbols to add before, after, and between errorText.\nconst errorTextPadding = {\n    min: 2,\n    max: 10,\n}\n\n\/\/ errorTextVariance: The minimum and maximum (inclusive) number of characters to add to the length of a class, template, system, or weapon name.\nconst errorTextVariance = {\n    min: -3,\n    max: 3\n}\n\n\/\/targets - Gets the data for your currently selected target(s) and stores it for later use. Do not change.\nlet targets = Array.from(game.user.targets);\n\n\/\/Functions\n\/\/zeroPad - Adds a set number 0s to the fed number to produce a consistent length number.\nconst zeroPad = (num, places) => String(num).padStart(places, \'0\');\n\n\/\/sort_features - Sorts the feature list for the scanned target\nfunction sort_features(a, b) {\n    return b.Origin.base - a.Origin.base\n}\n\n\/\/ isFeatureAbominable - checks if the given feature is the Abominable feature from Horror\nfunction isFeatureAbominable(f) {\n    return f.Origin.name === \"Horror\" && f.Name === \"Abominable\" && !f.Origin.base && !f.Destroyed\n}\n\n\/\/ isTargetAbominable - checks if the target has the Abominable feature from Horror\nfunction isTargetAbominable(sc_dir) {\n    return sc_dir._features.filter(isFeatureAbominable).length > 0\n}\n\n\/\/construct_features - Builds out the list of selectable features for the scanned target, includes support for exotics.\nfunction construct_features(sc_dir, o) {\n    let sc_list = ``;\n    const isAbominable = isTargetAbominable(sc_dir)\n    sc_list += `<p>${isAbominable && o !== \"Horror\" ? glitchyError(o) : o}<\/p>`\n    let sc_features = sc_dir._features.filter(f => f.Origin.name === o).sort(sort_features)\n    sc_features.forEach(i => {\n        let sc_name;\n        let sc_desc;\n        const glitchOut = isAbominable && !isFeatureAbominable(i)\n        if (!glitchOut && i.Origin.name === \"EXOTIC\" && !i.Origin.base) {\n            sc_name = \"<code class=\\\"horus--subtle\\\">UNKNOWN EXOTIC SYSTEM<\/code>\";\n            sc_desc = \"???\";\n        }\n        else {\n            sc_name = i.Name;\n            if (i.Effect) {\n                sc_desc = i.Effect;\n            } else {\n                sc_desc = \"No description given.\";\n            }\n            if (i.Trigger) {\n                sc_desc = `Trigger:${i.Trigger}<br>${sc_desc}`;\n            }\n        }\n        let sc_entry = `<details><summary>${glitchOut ? glitchyError(sc_name) : sc_name}<\/summary><p>${glitchOut ? glitchyErrorMultiline(sc_desc) : sc_desc}<\/p><\/details>`;\n        sc_list += sc_entry;\n    });\n    return sc_list\n}\n\n\/\/construct_weapons - Builds out the table of weapons for the scanned target, includes support for exotics.\nfunction construct_weapons(sc_dir, o, sc_tier) {\n    let sc_weapons = ``;\n    let sc_features = sc_dir._features.filter(f => f.Origin.name === o).sort(sort_features)\n    const glitchOut = isTargetAbominable(sc_dir)\n    sc_features.forEach(i => {\n        let sc_name = ``;\n        let sc_desc = ``;\n        let sc_entry = ``;\n        let sc_range = ``;\n        let sc_damage = ``;\n        let sc_accuracy = ``;\n        if (!i.WepType) { return sc_weapons }\n        sc_weapons += `<table>`;\n        if (!glitchOut && i.Origin.name === \"EXOTIC\" && !i.Origin.base) {\n            sc_name = \"<tr><th><code class=\\\"horus--subtle\\\">UNKNOWN EXOTIC WEAPON<\/code><\/th><\/tr>\";\n            sc_desc = \"<tr><td>???<\/td><\/tr>\";\n            sc_entry = sc_name + sc_desc;\n        } else {\n            sc_name = `<tr><th colspan=\"4\">${glitchOut ? glitchyError(i.Name) : i.Name}<\/th><\/tr>`;\n            sc_entry += sc_name;\n            sc_desc = `<tr>`;\n            sc_desc += `<td>+${glitchOut ? glitchyValue() : i.AttackBonus[sc_tier - 1]} ATTACK<\/td>`;\n            if (i.Accuracy[sc_tier - 1]) {\n                if (i.Accuracy[sc_tier - 1] > 0) {\n                    sc_accuracy = \'+\' + i.Accuracy[sc_tier - 1] + \' ACCURACY\'\n                } else {\n                    sc_accuracy = \'-\' + i.Accuracy[sc_tier - 1] + \' DIFFICULTY\'\n                }\n            }\n            sc_desc += `<td>${glitchOut ? glitchyError(sc_accuracy) : sc_accuracy}<\/td>`;\n            if (i.Range.length > 0) { i.Range.forEach(r => sc_range += (glitchOut ? glitchyError(r.RangeType) : r.RangeType) + \' \' + (glitchOut ? glitchyValue() : r.Value) + \'&nbsp&nbsp&nbsp\') }\n            sc_desc += `<td>${sc_range}<\/td>`;\n            if (i.Damage.length > 0) { i.Damage[sc_tier - 1].forEach(d => sc_damage += (glitchOut ? glitchyValue() : d.Value) + \' \' + (glitchOut ? glitchyError(d.DamageType) : d.DamageType) + \'&nbsp&nbsp&nbsp\') }\n            sc_desc += `<td>${sc_damage}<\/td>`;i.Damage\n            if (glitchOut) {\n                sc_desc += `<td>${glitchyError(\"NLOADED\")}<\/td>`\n            } else if (i.Loaded) { sc_desc += `<td>LOADED<\/td>` } else { sc_desc += `<td>UNLOADED<\/td>` }\n            if (glitchOut) {\n                sc_desc += `<td>${glitchyError(\"USES:\") + \" \" + glitchyValue() + \"\/\" + glitchyValue()}<\/td>`\n            } else if (i.Uses > 0 && i.BaseLimit > 0) { sc_desc += `<td>USES: ${i.Uses}\/${i.BaseLimit}<\/td>` }\n            sc_desc += `<tr>`;\n            if (i.Trigger) {\n                sc_desc += `<tr><td colspan=\"6\"><details><summary>Trigger<\/summary><p>${glitchOut ? glitchyErrorMultiline(i.Trigger) : i.Trigger}<\/p><\/details><\/td><\/tr>`;\n            }\n            if (i.OnHit) {\n                sc_desc += `<tr><td colspan=\"6\"><details><summary>On Hit<\/summary><p>${glitchOut ? glitchyErrorMultiline(i.OnHit) : i.OnHit}<\/p><\/details><\/td><\/tr>`;\n            }\n            if (i.Effect) {\n                sc_desc += `<tr><td colspan=\"6\">${glitchOut ? glitchyErrorMultiline(i.Effect) : i.Effect}<\/td><\/tr>`;\n            }\n            if (i.Tags.length > 0) {\n                sc_desc += `<tr><td colspan=\"6\"><details><summary>Tags<\/summary>`;\n                i.Tags.forEach((t) => {\n                    const text = t.Tag.Name.replace(\"{VAL}\", t.Value)\n                    sc_desc += `<p>${glitchOut ? glitchyError(text) : text}<\/p>`;\n                });\n                sc_desc += `<\/details><\/td><\/tr>`;\n            }\n            sc_entry += sc_desc;\n        }\n        sc_weapons += sc_entry;\n        sc_weapons += `<\/table>`\n    });\n    return sc_weapons\n}\n\n\/\/construct_templates\nfunction construct_templates(sc_dir) {\n    let sc_templates = ``;\n    let sc_temp = sc_dir._templates;\n    const glitchOut = isTargetAbominable(sc_dir)\n    if (!sc_temp || sc_temp.length === 0) {\n        sc_templates += \"<p>NONE<\/p>\";\n    } else {\n        sc_temp.forEach(i => {\n            let sc_entry = `<p>${glitchOut && i.Name !== \"Horror\" ? glitchyError(i.Name) : i.Name}<\/p>`;\n            sc_templates += sc_entry;\n        });\n    }\n\n    sc_templates += \"<br>\";\n    return sc_templates\n}\n\nfunction genRandomInt(min, max) {\n    return Math.floor(Math.random() * (1 + max - min)) + min\n}\n\nfunction getRandomItem(arr) {\n    return arr.length === 0 ? null : arr[genRandomInt(0, arr.length - 1)]\n}\n\nfunction generate_glitch_text(length) {\n    const out = []\n    let remaining = length\n    if (glitchSymbols.length === 0) {\n        throw Error(\"No glitch symbols available\")\n    }\n    while (remaining > 0) {\n        const next = getRandomItem(glitchSymbols)\n        out.push(next)\n        remaining -= next.length\n    }\n    return out.join(\'\').substring(0, Math.max(0, length + 1))\n}\n\nfunction generate_error_text(length) {\n    const out = []\n    let remaining = length\n    while (remaining > Math.max(0, genRandomInt(errorTextPadding.min, errorTextPadding.max))) {\n        const available = errorText.filter(s => s.length <= remaining)\n        if (available.length === 0) {\n            break;\n        }\n        const nextText = getRandomItem(available)\n        remaining -= nextText.length\n        const before = Math.max(0, Math.min(remaining, genRandomInt(errorTextPadding.min, errorTextPadding.max)))\n        const beforeText = generate_glitch_text(before)\n        remaining -= beforeText.length\n        out.push(beforeText)\n        out.push(nextText)\n    }\n    out.push(generate_glitch_text(remaining))\n    return out.join(\"\")\n}\n\nfunction escapeHtml(s) {\n    return s.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\n}\n\nfunction glitchyValue() {\n    const glitchTextLength = Math.max(1, genRandomInt(glitchNumberLength.min, glitchNumberLength.max))\n    return `<code class=\"horus--subtle\">${escapeHtml(generate_glitch_text(glitchTextLength))}<\/code>`\n}\n\nfunction glitchyError(realText) {\n    const errorTextLength = Math.max(1, genRandomInt(realText.length + errorTextVariance.min, realText.length + errorTextVariance.max))\n    return `<code class=\"horus--subtle\">${escapeHtml(generate_error_text(errorTextLength))}<\/code>`\n}\n\nconst newlineSplitRegex = \/<(p|br|div|li|table|tr)>\/\n\nfunction glitchyErrorMultiline(realText) {\n    return realText.split(newlineSplitRegex).map(glitchyError).join(\"<br>\")\n}\n\nconst journalFolder = game.folders.getName(journalFolderName)\nif (!journalFolder && journalFolderName.length > 0) {\n    try {\n        await Folder.create({ name: journalFolderName, type: \"JournalEntry\" })\n    } catch (error) {\n        ui.notifications.error(`${journalFolderName} does not exist and must be created manually by a user with permissions to do so.`);\n        return;\n    }\n}\n\ntargets.forEach(async (target) => {\n    let sc_dir = await target.document.actor.system.derived.mm_promise;\n    const glitchOut = isTargetAbominable(sc_dir)\n    let hase_table_html = `\n    <p><img style=\"border: 3px dashed #000000; float: left; margin-right: 5px; margin-left: 5px;\" src=\"${target.document.actor.img}\" width=\"30%\" height=\"30%\" \/><\/p>\n    <div style=\"color: #000000; width: 65%; float: right; text-align: left;\">\n    <table>\n        <tr>\n            <th>HULL<\/th><th>AGI<\/th><th>SYS<\/th><th>ENG<\/th>\n        <\/tr>\n        <tr>\n            <td>${glitchOut ? glitchyValue() : sc_dir.Hull || 0}<\/td><td>${glitchOut ? glitchyValue() : sc_dir.Agi || 0}<\/td><td>${glitchOut ? glitchyValue() : sc_dir.Sys || 0}<\/td><td>${glitchOut ? glitchyValue() : sc_dir.Eng || 0}<\/td>\n        <\/tr>\n    <\/table>\n    `\n    let stat_table_html = `\n    <table>\n        <tr>\n            <th>Armor<\/th><th>HP<\/th><th>Heat<\/th><th>Speed<\/th>\n        <\/tr>\n        <tr>\n            <td>${glitchOut ? glitchyValue() : sc_dir.Armor}<\/td><td>${glitchOut ? glitchyValue() : sc_dir.CurrentHP}\/${glitchOut ? glitchyValue() : sc_dir.MaxHP}<\/td><td>${glitchOut ? glitchyValue() : sc_dir.CurrentHeat || 0}\/${glitchOut ? glitchyValue() : sc_dir.HeatCapacity || 0}<\/td><td>${glitchOut ? glitchyValue() : sc_dir.Speed}<\/td>\n        <\/tr>\n        <tr>\n            <th>Evasion<\/th><th>E-Def<\/th><th>Save<\/th><th>Sensors<\/th>\n        <\/tr>\n        <tr>\n            <td>${glitchOut ? glitchyValue() : sc_dir.Evasion}<\/td><td>${glitchOut ? glitchyValue() : sc_dir.EDefense}<\/td><td>${glitchOut ? glitchyValue() : sc_dir.SaveTarget}<\/td><td>${glitchOut ? glitchyValue() : sc_dir.SensorRange}<\/td>\n        <\/tr>\n        <tr>\n            <th>Size<\/th><th>Activ<\/th><th>Struct<\/th><th>Stress<\/th>\n        <\/tr>\n        <tr>\n            <td>${glitchOut ? glitchyValue() : sc_dir.Size}<\/td><td>${glitchOut ? glitchyValue() : sc_dir.Activations || 1}<\/td><td>${glitchOut ? glitchyValue() : sc_dir.CurrentStructure || 0}\/${glitchOut ? glitchyValue() : sc_dir.MaxStructure || 0}<\/td><td>${glitchOut ? glitchyValue() : sc_dir.CurrentStress || 0}\/${glitchOut ? glitchyValue() : sc_dir.MaxStress || 0}<\/td>\n        <\/tr>\n    <\/table>\n    `\n    console.log(sc_dir)\n    let sc_class = (!sc_dir._classes || sc_dir._classes.length === 0) ? \"NONE\" : glitchOut ? glitchyError(sc_dir._classes[0].Name) : sc_dir._classes[0].Name\n    let sc_tier = sc_dir.Tier ? sc_dir.Tier : 0\n    let sc_templates = construct_templates(sc_dir)\n    let sc_list = ``\n    let sc_weapons = ``\n    if (!sc_dir._features || sc_dir._features.length === 0) {\n        sc_list += \"<p>NONE<\/p>\";\n        sc_weapons += \"<p>NONE<\/p>\";\n    } else {\n        let sc_origins = [];\n        sc_dir._features.forEach(f => {\n            let origin = f.Origin.name;\n            if (!sc_origins.includes(origin)) {\n                sc_origins.push(origin);\n            }\n        });\n        sc_origins.forEach(o => {\n            sc_list += construct_features(sc_dir, o);\n            sc_weapons += construct_weapons(sc_dir, o, sc_tier);\n        });\n    }\n\n    \/\/ ChatMessage.create({\n    \/\/     user: game.user._id,\n    \/\/     content: `<h2>Scan results: ${sc_dir.Name}<\/h2>` + `<h3>Class: ${sc_class}, Tier ${sc_tier}<\/h3>`  + hase_table_html + stat_table_html + `<h3>Templates:<\/h3>` + sc_templates + `<h3>Systems:<\/h3>` + sc_list\n    \/\/ });\n\n    var scanContent = `<h2>Scan results: ${glitchOut ? glitchyError(sc_dir.Name) : sc_dir.Name}<\/h2>` + `<h3>Class: ${sc_class}, Tier ${glitchOut ? glitchyValue() : sc_tier}<\/h3>` + hase_table_html + stat_table_html + `<\/div><div style=\"color: #000000; width: 100%; float: right; text-align: left;\"><h3>Weapons:<\/h3>` + sc_weapons + `<h3>Templates:<\/h3>` + sc_templates + `<h3>Systems:<\/h3>` + sc_list + `<\/div>`\n\n    \/\/This checks and updates the scan entry for the target(s) if a single scan entry exists in the specified folder for the target(s) along with the updateExisting flag.\n    \/\/If either are false then this creates a new scan entry.\n\n    let rootScanFolder = journalFolderName ? journalFolder : game.journal;\n    let scanFolderId = journalFolderName ? journalFolder.id : null;\n\n    let scanObj = {};\n\n    scanObj.folder = scanFolderId;\n\n    let scanEntry;\n\n    let matchingJournalEntries = rootScanFolder.contents.filter(e => e.name.match(sc_dir.Name));\n\n    if (matchingJournalEntries.length === 1 && updateExisting === true) {\n        console.log(\"Updating an existing scan\")\n        scanObj.name = matchingJournalEntries[0].name;\n        scanObj._id = matchingJournalEntries[0]._id;\n        scanObj.text = {};\n        scanObj.text.content = scanContent;\n        scanEntry = game.journal.getName(scanObj.name);\n        let scanPage = scanEntry.pages.getName(scanObj.name)\n        await scanPage.update(scanObj);\n    } else {\n        console.log(\"Creating a new scan\")\n        let scanCount = zeroPad(rootScanFolder.contents.filter(e => e.name.startsWith(nameTemplate)).length + startingNumber, numberLength);\n        scanObj.name = nameTemplate + scanCount + ` - ` + sc_dir.Name;\n        scanObj.content = scanContent;\n        scanEntry = await JournalEntry.create(scanObj);\n    }\n\n    scanEntry.update({ permission: { default: permissionLevel } });\n    scanEntry.sheet.render(true);\n\n})","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Compendium.lancer.core_macros.z0pdvwE0FitMzwRJ"}},"ownership":{"default":0,"2a2IgZ2kiAqXSGqu":3},"_stats":{"systemId":"lancer","systemVersion":"1.5.4","coreVersion":"10.303","createdTime":1689295072726,"modifiedTime":1689295343715,"lastModifiedBy":"2a2IgZ2kiAqXSGqu"},"folder":null,"sort":0,"_id":"UEca0sSwObxVLfYi"}
{"_id":"angOaW77n9ZZZqgq","name":"Custom Paint Job","type":"script","author":"2a2IgZ2kiAqXSGqu","img":"systems/lancer/assets/icons/macro-icons/system.svg","scope":"global","command":"// This macro is designed to be used with Triggler from Combat Utility Belt. Otherwise, it can be used as an alternative to manually using the Structure macro. It also includes \"destroying\" the Custom Paint Job system in order to check if it's been used between full repairs.\n\nlet cpjActor = game.actors.get(canvas.tokens.controlled[0].actor.id);\n//console.log(cpjActor);\n\nasync function scratchedThePaint(cpjId) {\n    await cpjActor.update({data: {hp: 1}});\n    //console.log(cpjActor)\n    await cpjActor.updateEmbeddedDocuments(\"Item\",[{_id: cpjId, 'system.destroyed':true}])\n    return \"Done.\";\n};\n\nif (canvas.tokens.controlled.length !== 1) {\n    ui.notifications.error(\"Select one and only one token\");\n    return;\n}\n\nlet cpj = cpjActor.items.find(\n    i => i.name.toLowerCase() === \"custom paint job\"\n);\nif (cpj) {\n    if (!cpj.system.destroyed) {\n        console.log(\"Custom Paint Job found.\");\n        let roll = new Roll('1d6');\n        await roll.roll();\n        console.log(`CPJ rolled ${roll.total}`);\n        if (roll.total === 6) {\n            await scratchedThePaint(cpj._id)\n            canvas.tokens.controlled[0].drawBars();\n        } else {\n            game.lancer.prepareStructureMacro(cpjActor.id);\n        }\n        return;\n    } else {\n        console.log(\"Custom Paint Job has already been used.\");\n    }\n}\n// If we reach here, either the actor doesn't have CPJ or it's already been used.\ngame.lancer.prepareStructureMacro(canvas.tokens.controlled[0].actor.id);\ncanvas.tokens.controlled[0].drawBars();","folder":null,"sort":0,"permission":{"default":0,"2a2IgZ2kiAqXSGqu":3},"flags":{}}
{"_id":"Yx1pdJKNYFKkIYAZ","name":"Mimic Gun","type":"script","author":"2a2IgZ2kiAqXSGqu","img":"systems/lancer/assets/icons/macro-icons/d20-framed.svg","scope":"global","command":"// Calculate a Range for the Mimic Gun.\nasync function getRange() {\n  const roll = await new Roll(\"d20\").roll({ async: true });\n  const text =\n  `<i class=\"cci cci-range i--m i--dark\"></i> ${roll.total}` +\n  `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;` +\n  `${Math.ceil(roll.total / 2) + 1} ` +\n  `<i class=\"cci cci-kinetic i--m damage--kinetic\"></i>`;\n  return text;\n}\n\n// Construct HTML message table for chat message.\nasync function buildMessageTable() {\n  const messageTable =  \n    \"<b><h2>Mimic Gun Ranges</h2></b>\" + \n    \"<p><b>Range 1: </b>\" + await getRange() +\n    \"<hr><p><b>Range 2: </b>\" + await getRange() +\n    \"<hr><p><b>Range 3: </b>\" + await getRange()\n  return messageTable;\n}\n\n// Construct the chat message.\nasync function buildChatData() {\n  return {\n    user: game.user.id,\n    speaker: ChatMessage.getSpeaker(),\n    content: await buildMessageTable()\n  };\n}\n\nChatMessage.create(await buildChatData(), {});","folder":null,"sort":0,"permission":{"default":0,"2a2IgZ2kiAqXSGqu":3},"flags":{}}
{"_id":"NZr08LHM7ZqSoAvL","name":"Reload","type":"script","author":"2a2IgZ2kiAqXSGqu","img":"systems/lancer/assets/icons/ammo.svg","scope":"global","command":"(async ()=>{\n    \n    if (canvas.tokens.controlled.length !== 1) {\n        ui.notifications.info(\"Select one and only one token\");\n        return;\n    }\n    await canvas.tokens.controlled[0].actor.reload_all_items()\n    ui.notifications.info(`${actor.name} reloaded all weapons!`);\n\n})();","folder":null,"sort":0,"flags":{},"ownership":{"default":0,"2a2IgZ2kiAqXSGqu":3},"_stats":{"systemId":null,"systemVersion":null,"coreVersion":null,"createdTime":null,"modifiedTime":null,"lastModifiedBy":null}}
{"name":"Ruin Tokens","type":"script","author":"2a2IgZ2kiAqXSGqu","img":"systems/lancer/assets/icons/macro-icons/generic_item.svg","scope":"global","command":"function isBiological(token) {\n    let actorItems = game.actors.filter(x => x.id === token.document.actorId)[0].items;\n    for (let item of actorItems.entries()) {\n        if (item[1].type === 'npc_class' && item[1].system.role === 'biological') {\n            console.log(`${token.name} is biological.`)\n            return true;\n        } else {\n            console.log(`${token.name} is not biological.`)\n            return false;\n        }\n    }\n}\n\nif (canvas.tokens.controlled.length === 0) {\n    ui.notifications.error(\"Please select one or more tokens.\");\n    return;\n}\ncanvas.tokens.controlled.forEach(async t => {\n    if (isBiological(t)) {\n        ui.notifications.info(`${t.name} is biological. Skipping.`)\n        return;\n    }\n    // CONFIG BELOW:\n    // Data path where your images are stored.\n    let IMAGE_PATH = \"lancer-wrecks\";\n\n    // Dictionary for mapping sizes to subdirectories under IMAGE_PATH.\n    // Keys are the potential sizes a LancerActor may have; values are the subdirectory names.\n    // Store your images by size in each subdirectory.\n    let SIZE_PATHS = {\n        0.5: \"S-HALF\",\n        1: \"S1\",\n        2: \"S2\",\n        3: \"S3\",\n        4: \"S4\"\n    };\n\n    // Script:\n    let size = t.actor.system.derived.mm.Size;\n    let sizePath = SIZE_PATHS[size];\n    var imgString;\n    if (!!sizePath) {\n        var wreckFileList\n        try {\n            let wreckFilePicker = await FilePicker.browse(\"data\", `/${IMAGE_PATH}/${sizePath}`);\n            wreckFileList = wreckFilePicker.files;\n            console.log(wreckFileList);\n            let numImages = wreckFileList.length;\n            // Get random number between 1 and N, where n is number of images stored for mech size.\n            let rand = Math.floor(Math.random() * numImages);\n            imgString = wreckFileList[rand];\n        } catch (error) {\n            ui.notifications.warn(`${error}. Skipping image replacement.`);\n        }\n        \n    } else {\n        ui.notifications.warn(`Missing size path configuration for Size ${size} for ${t.name}. Skipping image replacement.`);\n    }\n\n    console.log(`Picked ${imgString} for ${t.name}`);\n\n    let data = [{\n        _id: t.id,\n        \"texture.src\": imgString\n    }];\n\n    canvas.scene.updateEmbeddedDocuments(\"Token\", data);\n    t.actor.update({ \"system.hp\": size * 10, \"system.heat\": 0, \"system.burn\": 0 });\n    game.combat.getCombatantByToken(t.id)?.delete();\n    // t.update(data);\n    // t.refresh();\n});","folder":null,"sort":0,"ownership":{"default":0,"2a2IgZ2kiAqXSGqu":3},"flags":{},"_stats":{"systemId":"lancer","systemVersion":"1.5.2","coreVersion":"10.291","createdTime":1680276334252,"modifiedTime":1680276336971,"lastModifiedBy":"2a2IgZ2kiAqXSGqu"},"_id":"xI9yomXwRuzN9yIC"}
