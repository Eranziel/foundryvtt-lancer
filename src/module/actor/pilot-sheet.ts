import { LANCER } from "../config";
const lp = LANCER.log_prefix;
import { LancerActorSheet } from "./lancer-actor-sheet";
import type { HelperOptions } from "handlebars";
import { buildCounterHeader, buildCounterHTML } from "../helpers/item";
import { ref_params, resolve_ref_element, simple_ref_slot } from "../helpers/refs";
import { resolve_dotpath } from "../helpers/commons";
import { LancerActor, LancerMECH, LancerPILOT } from "./lancer-actor";
import { fetchPilotViaCache, fetchPilotViaShareCode, pilotCache } from "../util/compcon";
import { LancerItem, LancerItemType } from "../item/lancer-item";
import { clicker_num_input } from "../helpers/actor";
import { ResolvedDropData } from "../helpers/dragdrop";
import { EntryType } from "../enums";
import { PackedPilotData } from "../util/unpacking/packed-types";

const shareCodeMatcher = /^[A-Z0-9\d]{6}$/g;
const COUNTER_MAX = 8;

/**
 * Extend the basic ActorSheet
 */
export class LancerPilotSheet extends LancerActorSheet<EntryType.PILOT> {
  /**
   * Extend and override the default options used by the Pilot Sheet
   * @returns {Object}
   */
  static get defaultOptions(): ActorSheet.Options {
    return mergeObject(super.defaultOptions, {
      classes: ["lancer", "sheet", "actor", "pilot"],
      template: `systems/${game.system.id}/templates/actor/pilot.hbs`,
      width: 800,
      height: 800,
      tabs: [
        {
          navSelector: ".lancer-tabs",
          contentSelector: ".sheet-body",
          initial: "tactical",
        },
      ],
    });
  }

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {JQuery}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html: JQuery) {
    super.activateListeners(html);

    // Everything below here is only needed if the sheet is editable
    if (!this.options.editable) return;

    if (this.actor.isOwner) {
      // Item/Macroable Dragging

      // Cloud download
      let download = html.find('.cloud-control[data-action*="download"]');
      let actor = this.actor;
      if (actor.is_pilot() && actor.system.cloud_id) {
        download.on("click", async ev => {
          ev.stopPropagation();

          let self = await this.getData();
          // Fetch data to sync
          let raw_pilot_data = null;
          if (self.rawID.match(shareCodeMatcher)) {
            // pilot share codes
            ui.notifications!.info("Importing character from share code...");
            console.log(`Attempting import with share code: ${self.rawID}`);
            try {
              raw_pilot_data = await fetchPilotViaShareCode(self.rawID);
            } catch (error) {
              ui.notifications!.error("Error importing from share code. Share code may need to be refreshed.");
              console.error(`Failed import with share code ${self.rawID}, error:`, error);
              return;
            }
          } else if (self.rawID) {
            ui.notifications!.warn(
              "Invalid share code format. Share codes must be exactly six alphanumeric characters."
            );
            console.warn(`Failed import with invalid share code format: ${self.rawID}`);
            return;
          } else if (self.vaultID != "") {
            // Vault ID from a logged-in Comp/Con account
            ui.notifications!.info("Importing character from COMP/CON account...");
            const cachedPilot = self.pilotCache.find(p => p.cloudID == self.vaultID);
            if (cachedPilot != undefined) {
              try {
                raw_pilot_data = await fetchPilotViaCache(cachedPilot);
              } catch (error) {
                ui.notifications!.error(
                  "Failed to import from COMP/CON account. Try refreshing the page to reload pilot list."
                );
                console.error(`Failed to import vaultID ${self.vaultID} via pilot list, error:`, error);
                return;
              }
            } else {
              ui.notifications!.error(
                "Failed to import from COMP/CON account. Try refreshing the page to reload pilot list"
              );
              console.error(`Failed to find pilot in cache, vaultID: ${self.vaultID}`);
              return;
            }
          } else {
            ui.notifications!.error(
              "Could not find character to import! No pilot selected via dropdown and no share code entered."
            );
            console.error(`Failed to import pilot. vaultID: ${self.vaultID}, rawID: ${self.rawID}`);
            return;
          }
          await actor.importCC(raw_pilot_data);
        });
      } else {
        download.addClass("disabled-cloud");
      }

      // JSON Import
      if (actor.is_pilot()) {
        html.find("#pilot-json-import").on("change", ev => this._onPilotJsonUpload(ev, actor));
      }

      // editing rawID clears vaultID
      // (other way happens automatically because we prioritise vaultID in commit)
      let rawInput = html.find('input[name="rawID"]');
      rawInput.on("input", async ev => {
        if ((ev.target as any).value != "") {
          (html.find('select[name="vaultID"]')[0] as any).value = "";
        }
      });

      // Mech swapping
      let mechActivators = html.find(".activate-mech");
      mechActivators.on("click", async ev => {
        ev.stopPropagation();
        let mech = (await resolve_ref_element(ev.currentTarget)) as LancerActor | null;

        if (!mech || !mech.is_mech()) return;

        this.activateMech(mech);
      });

      let mechDeactivator = html.find(".deactivate-mech");
      mechDeactivator.on("click", async ev => {
        ev.stopPropagation();

        this.deactivateMech();
      });
    }
  }

  _onPilotJsonUpload(ev: JQuery.ChangeEvent<HTMLElement, undefined, HTMLElement, HTMLElement>, actor: LancerActor) {
    let files = (ev.target as HTMLInputElement).files;
    let jsonFile: File | null = null;
    if (files) jsonFile = files[0];
    if (!jsonFile) return;

    console.log(`${lp} Selected file changed`, jsonFile);
    const fr = new FileReader();
    fr.readAsBinaryString(jsonFile);
    fr.addEventListener("load", (ev: ProgressEvent) => {
      this._onPilotJsonParsed((ev.target as FileReader).result as string, actor);
    });
  }

  async _onPilotJsonParsed(fileData: string | null, actor: LancerActor) {
    if (!fileData) return;
    const pilotData = JSON.parse(fileData) as PackedPilotData;
    console.log(`${lp} Pilot Data of selected JSON:`, pilotData);

    if (!pilotData) return;
    ui.notifications!.info(`Starting import of ${pilotData.name}, Callsign ${pilotData.callsign}. Please wait.`);
    console.log(`${lp} Starting import of ${pilotData.name}, Callsign ${pilotData.callsign}.`);
    console.log(`${lp} Parsed Pilot Data pack:`, pilotData);

    await actor.importCC(pilotData);
    ui.notifications!.info(`Import of ${pilotData.name}, Callsign ${pilotData.callsign} complete.`);
    console.log(`${lp} Import of ${pilotData.name}, Callsign ${pilotData.callsign} complete.`);
    this.render();
  }

  async activateMech(mech: LancerMECH) {
    // TODO
    let pilot = this.actor as LancerPILOT;
    // Set active mech
    await pilot.update({ "system.active_mech": mech.uuid });
    await mech.update({ "system.pilot": pilot.uuid });
  }

  async deactivateMech() {
    // Unset active mech
    await this.actor.update({
      active_mech: null,
    });
  }

  async getData() {
    const data = await super.getData(); // Not fully populated yet!
    // TODO
    /*

    data.active_mech = await data.mm.ActiveMech();
    data.pilotCache = pilotCache();

    // use the select if and only if we have the pilot in our cache
    let useSelect = data.mm.CloudID && data.pilotCache.find(p => p.cloudID == data.mm.CloudID);

    if (useSelect) {
      // if this is a vault id we know of
      data.vaultID = data.mm.CloudID;
      data.rawID = "";
    } else if (data.mm.CloudID && data.mm.CloudID.match(shareCodeMatcher)) {
      // If this was a share code, show it in the input box so it can be edited
      data.rawID = data.mm.CloudID;
      data.vaultID = "";
    } else {
      data.rawID = "";
      data.vaultID = "";
    }
    */

    return data;
  }

  // Pilots can handle most stuff
  canRootDrop(item: ResolvedDropData): boolean {
    // Accept mechs, so as to change their pilot
    if (item.type == "Actor" && item.document.is_mech()) {
      return true;
    }

    // Accept pilot items
    if (
      item.type == "Item" &&
      (item.document.is_core_bonus() ||
        item.document.is_pilot_weapon() ||
        item.document.is_pilot_armor() ||
        item.document.is_pilot_gear() ||
        item.document.is_license() ||
        item.document.is_skill() ||
        item.document.is_talent() ||
        item.document.is_organization() ||
        item.document.is_reserve())
    ) {
      return true;
    }

    // Reject anything else
    return false;
  }

  async onRootDrop(base_drop: ResolvedDropData, event: JQuery.DropEvent, _dest: JQuery<HTMLElement>): Promise<void> {
    if (!this.actor.is_pilot()) return; // Just for types really

    // Take posession
    let [drop, is_new] = await this.quickOwnDrop(base_drop);
    let pilot = this.actor as LancerPILOT;
    let loadout = pilot.system.loadout;

    // Now, do sensible things with it
    if (drop.type == "Item") {
      // Handle all pilot item types
      if (drop.document.is_pilot_weapon()) {
        // If new weapon, try to equip to first empty slot / first post slot
        for (let i = 0; i <= loadout.weapons.length; i++) {
          if (!loadout.weapons[i]) {
            await pilot.update({
              [`system.loadout.weapons.${i}`]: drop.document.id,
            });
            break;
          }
        }
      } else if (drop.document.is_pilot_gear()) {
        // If new gear, try to equip to first empty slot / first post slot
        for (let i = 0; i <= loadout.gear.length; i++) {
          if (!loadout.gear[i]) {
            await pilot.update({
              [`system.loadout.gear.${i}`]: drop.document.id,
            });
            break;
          }
        }
      } else if (drop.document.is_pilot_armor()) {
        // If new armor, try to equip to first empty slot / first post slot
        for (let i = 0; i <= loadout.armor.length; i++) {
          if (!loadout.armor[i]) {
            await pilot.update({
              [`system.loadout.armor.${i}`]: drop.document.id,
            });
            break;
          }
        }
      } else if ((is_new && drop.document.is_talent()) || drop.document.is_skill()) {
        // If new skill or talent, reset to level 1
        await drop.document.update({ "system.rank": 1 });
      }
    } else if (drop.type == "Actor" && drop.document.is_mech()) {
      this.activateMech(drop.document);
    }
  }

  /* -------------------------------------------- */

  /**
   * Implement the _updateObject method as required by the parent class spec
   * This defines how to update the subject of the form when the form is submitted
   * @private
   */
  async _updateObject(event: Event, formData: any) {
    if (!this.actor.is_pilot()) return;
    // Do some pre-processing
    // Do these only if the callsign updated
    if (this.actor.system.callsign !== formData["callsign"]) {
      // Use the Actor's name for the pilot's callsign
      // formData["name"] = formData["data.callsign"];
      // Copy the pilot's callsign to the prototype token
      formData["token.name"] = formData["callsign"];
    }
    // Then let parent handle
    return super._updateObject(event, formData);
  }
}

export function pilot_counters(pilot: LancerPILOT, _helper: HelperOptions): string {
  let counter_detail = "";

  let counter_arr = pilot.system.custom_counters;

  for (let i = 0; i < counter_arr.length; i++) {
    // Only allow deletion if the Pilot is the source
    const counter = counter_arr[i];
    if (counter.max != null) {
      if (counter.max <= COUNTER_MAX) {
        counter_detail = counter_detail.concat(buildCounterHTML(counter, `system.custom_counters.${i}`, true));
      } else {
        counter_detail = counter_detail.concat(
          buildCounterHeader(counter, `system.custom_counters.${i}`, true),
          clicker_num_input(`system.custom_counters.${i}.val`, _helper),
          "</div>"
        );
      }
    }
  }

  return `
  <div class="card clipped double">
    <span class="lancer-header submajor" style="padding-right: 5px">
      <span>COUNTERS</span>
      <a class="gen-control fas fa-plus" data-action="append" data-path="system.custom_counters" data-action-value="(struct)counter"></a>
    </span>
    <div class="wraprow double">
      ${counter_detail}
    </div>
  </div>`;
}

export function all_mech_preview(_helper: HelperOptions): string {
  let active_mech: LancerMECH | null = _helper.data.root.active_mech;

  let html = ``;

  /// I still feel like this is pretty inefficient... but it's probably the best we can do for now
  game?.actors
    ?.filter(
      mech =>
        mech.is_mech() &&
        mech.system.pilot?.status == "resolved" &&
        mech.system.pilot.value.id === _helper.data.root.actor.id &&
        mech.id !== active_mech?.id
    )
    .map((inactive_mech_, k) => {
      // TODO: Figure out why the stored document type is so bizarre
      let inactive_mech = inactive_mech_ as unknown as LancerMECH;
      html = html.concat(`
      <div class="flexrow inactive-row">
        <a class="activate-mech" ${ref_params(inactive_mech)}><i class="cci cci-activate"></i></a>
        <div class="major valid ${EntryType.MECH} ref" ${ref_params(inactive_mech)}>${inactive_mech.name}</div>
      </div>
    `);
    });

  if (active_mech) return active_mech_preview(active_mech, "active_mech", _helper).concat(html);
  else return html;
}

export function active_mech_preview(mech: LancerMECH | null, path: string, _helper: HelperOptions): string {
  var html = ``;

  // Generate commons
  if (!mech) return simple_ref_slot(path, [EntryType.MECH], "uuid-ref", _helper);

  // Making ourselves easy templates for the preview in case we want to switch in the future
  let preview_stats_arr = [
    { title: "HP", icon: "mdi mdi-heart-outline", path: "CurrentHP" },
    { title: "HEAT", icon: "cci cci-heat", path: "CurrentHeat" },
    { title: "EVASION", icon: "cci cci-evasion", path: "Evasion" },
    { title: "ARMOR", icon: "mdi mdi-shield-outline", path: "Armor" },
    { title: "STRUCTURE", icon: "cci cci-structure", path: "CurrentStructure" },
    { title: "STRESS", icon: "cci cci-reactor", path: "CurrentStress" },
    { title: "E-DEF", icon: "cci cci-edef", path: "EDefense" },
    { title: "SPEED", icon: "mdi mdi-arrow-right-bold-hexagon-outline", path: "Speed" },
    { title: "SAVE", icon: "cci cci-save", path: "SaveTarget" },
    { title: "SENSORS", icon: "cci cci-sensor", path: "SensorRange" },
  ];

  var stats_html = ``;

  for (let i = 0; i < preview_stats_arr.length; i++) {
    const builder = preview_stats_arr[i];
    stats_html = stats_html.concat(`
    <div class="mech-preview-stat-wrapper">
      <i class="${builder.icon} i--m i--dark"> </i>
      <span class="major">${builder.title}</span>
      <span class="major">${resolve_dotpath(mech, builder.path)}</span>
    </div>`);
  }

  html = html.concat(`
  <div class="mech-preview">
    <div class="mech-preview-titlebar">
    <a class="deactivate-mech"><i class="cci cci-activate"></i></a>
      <span>ACTIVE MECH: ${mech.name}</span>
    </div>
    <img class="valid ${mech.type} ref" ${ref_params(mech)} src="${mech.img}"/>
    ${stats_html}
  </div>`);

  return html;
}
